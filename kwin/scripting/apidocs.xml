<root>
 <class name="workspace" type="singleton">
  <event name="currentDesktopChanged" signal="currentDesktopChanged" wslot="sl_currentDesktopChanged" wsignal="currentDesktopChaned">
   <param name="old_desk" type="integer">The number of the virtual desktop the user switched from.</param>
   <desc>Emitted when the user switches from a virtual desktop to another.</desc>
  </event>
  
  <event name="clientSetKeepAbove" siganl="clientSetKeepAbove" wslot="sl_clientSetKeepAbove" wsignal="clientSetKeepAbove">
   <param name="setabove_client" type="client">The Client whose 'Keep Above' property was set or cleared.</param>
   <param name="set" type="boolean">Specifies if the property was set or cleared</param>
   <desc>Emitted whenever a client's 'Keep Above' property is changed. setabove_client holds the client object of the client whose property was modified and the parameter 'set' is '1' if the 'Keep Above' was set, or '0' otherwise.</desc>
  </event>
  
  <method name="getAllClients">
   <return type="Array(client)"></return>
   <param name="desktop_no" type="integer">The desktop number belonging to which the clients are to be fetched.</param>
   <desc>Gets all clients on the virtual desktop desktop_no. If no desktop number is specified then it fetches all the clients. To specifically isolate clients which are on 'All desktops', set the desktop_no parameter to -1.</desc>
  </method>
  
  <event name="desktopPresenceChanged" signal="desktopPresenceChanged" wslot="sl_desktopPresenceChanged" wsignal="desktopPresenceChanged">
   <param name="moved_client" type="client">The client which was moved from desktop old_desk to the new one</param>
   <param name="old_desk" type="integer">The previous desktop on which the client was present</param>
   <desc>Emitted whenever a client is moved across virtual desktops. The client's previous desktop is available through the old_desk parameter, whereas the current desktop can be fetched using moved_client.desktop</desc>
  </event>
  
  <property name="currentDesktop" type="GO">
   <return type="integer"></return>
   <desc>Returns the current desktop number of the workspace.</desc>
  </property>
  
  <event name="clientAdded" signal="clientAdded" wslot="sl_clientAdded" wsignal="clientAdded">
   <param name="added_client" type="client">The client which was added.</param>
   <desc>Emitted whenever a new client is added to the workspace. This generally occurs when a new window is opened which includes dialog boxes, windows etc. However, it is NOT emitted for unmanaged clients like the Alt+Tab switcher.</desc>
  </event>
  
  <event name="clientManaging" signal="DIRECT_FUNCTION_CALL" wslot="sl_clientManaging" wsignal="clientManaging">
   <param name="managing_client" type="client">The client which is being managed.</param>
   <desc>Emitted whenever a client is being managed by the KWin subsystem. The difference between workspace.clientManaging and workspace.clientAdded is that clientManaging is emitted BEFORE clientAdded. Also, if KWin is restarted with a list of clients C, then the clientManaging event will be emitted for every client in C, but clientAdded will not.</desc>
  </event>
  
  <event name="clientMinimized" signal="DIRECT_FUNCTION_CALL" wslot="sl_clientMinimized" wsignal="clientMinimized">
   <param name="minimized_client" type="client">The client which was minimized.</param>
   <desc>Emitted whenever a client is minimized.</desc>
  </event>
  
  <event name="clientMaximizeSet" signal="DIRECT_FUNCTION_CALL" wslot="sl_clientMaximizeSet" wsignal="clientMaximizeSet">
   <param name="maximized_client" type="client">The client which was maximized (in a certain orientation).</param>
   <param name="horizontally" type="boolean">(true) if the client was maximized horizontally, (false) otherwise.</param>
   <param name="vertically" type="boolean">(true) if the client was maximized vertically, (false) otherwise.</param>
   <desc>Emitted whenever a client is maximized in a particular orientation. The orientation i.e. the rectangular direction in which the client was specified to occupy the entire available space is specified by the two parameters horizontally and vertically. If both are true, the client was maximized fully i.e. asked to occupy the entire workspace are available.</desc>
  </event>
  
  <event name="killWindowCalled" signal="DIRECT_FUNCTION_CALL" wslot="sl_killWindowCalled" wsignal="killWindowCalled">
   <param name="killwindow_client" type="client">The client handle to the kill window that was called.</param>
   <desc>Emitted whenever the user requests a Kill Window [generally using the Ctrl+Esc combination]. The parameter killwindow_client is not completely safe and may return kill windows out of order of invocation. This is just a fancy function, avoid using. Instead, use workspace.clientAdded and filter for incoming Kill Windows.</desc>
  </event>
  
  <event name="clientActivated" signal="clientActivated" wslot="sl_clientActivated" wsignal="clientActivated">
   <param name="activated_client" type="client">The client which was activated (or received focus).</param>
   <desc>Emitted whenever a client is given focus or 'activated'.</desc>
  </event>
  
  <method name="dimensions">
   <return type="qsize"></return>
   <desc>Returns the dimensions of the workspace in pixels.</desc>
  </method>
  
  <method name="desktopGridSize">
   <return type="qsize"></return>
   <desc>Returns the desktop size in grid units. In essence, it returns the order of a rectangular matrix, where each element is a virtual desktop and the rows and columns specify the number of virtual desktops and the way of arrangement.</desc>
  </method>
  
  <event name="clientFullScreenSet" signal="DIRECT_FUNCTION_CALL" wslot="sl_clientFullScreenSet" wsignal="clientFullScreenSet">
   <param name="fss_set" type="boolean">(true) if the client was switched to full screen mode, (false) if it was switched from full screen mode.</param>
   <param name="fss_client" type="client">The client which was set/unset to fullscreen.</param>
   <desc>Emitted whenever a client is set to full screen or unset. The fss_set parameter can be used to determine whether the client was set or unset.</desc>
  </event>
  
  <method name="activeClient">
   <return type="client"></return>
   <desc>Returns the client which currently has focus.</desc>
  </method>
  
  <method name="clientGroups">
   <return type="Array(clientgroup)"></return>
   <desc>Returns an array of all the ClientGroups from the current workspace.</desc>
  </method>
  
  <event name="clientUnminimized" signal="DIRECT_FUNCTION_CALL" wslot="sl_clientUnminimized" wsignal="clientUnminimized">
   <param name="unm_client" type="client">The client which was unminimzed.</param>
   <desc>Emitted whenever a client is Unminimized (or restored).</desc>
  </event>
  
  <alias name="clientRestored" of="clientUnminimized"></alias>
 </class>
 
 <class name="toplevel" type="floating">
  <method name="x">
   <return type="integer"></return>
   <desc>Returns the x co-ordinate of the toplevel client (or the client).</desc>
  </method>
  
  <method name="y">
   <return type="integer"></return>
   <desc>Returns the y co-ordinate of the toplevel client (or the client).</desc>
  </method>
  
  <method name="width">
   <return type="integer"></return>
   <desc>Returns the width of the toplevel client (or the client).</desc>
  </method>
  
  <method name="height">
   <return type="integer"></return>
   <desc>Returns the height of the toplevel client (or the client).</desc>
  </method>
  
  <method name="size">
   <return type="qsize"></return>
   <desc>Returns the size of the toplevel client (or the client).</desc>
  </method>
  
  <method name="pos">
   <return type="qpoint"></return>
   <desc>Returns the position of the toplevel client (or the client).</desc>
  </method>
  
  <method name="opacity">
   <return type="decimal"></return>
   <desc>Returns the opacity (or 1 - transperency) of the toplevel client (or the client).</desc>
  </method>
  
  <method name="hasAlpha">
   <return type="bool"></return>
   <desc>Returns (true) if the client can be made translucent i.e. opacity can be set to values other than 0 or 1, (false) otherwise. NOTE: If compositing is OFF, then clients may still show that translucency is possible, but translucency is not possible without compositing being ON.</desc>
  </method>
  
  <method name="setOpacity">
   <param name="opacity_v" type="decimal">The opacity to be set (on a scale of 0-1).</param>
   <desc>Sets the opacity of the client to opacity_v or sets transperency to (1 - opacity_v). NOTE: If compositing is OFF, this function has no effect for any values between 0 and 1 (exclusive).</desc>
  </method>
 </class>
 
 <class name="client" type="floating" superclass="toplevel">
  <method name="caption">
   <return type="string"></return>
   <desc>Returns the caption of the caption (or the title) of the window.</desc>
  </method>
  
  <event name="clientMoved" signal="clientMoved" wslot="sl_clientMoved" wsignal="clientMoved">
   <desc>Emitted whenever the client is moved or it's geometry changed. This includes when a client is resized.</desc>
  </event>
  
  <event name="onSetKeepAbove" signal="s_setKeepAbove" wslot="DIRECT_CONNECTION" wsignal="onSetKeepAbove">
   <param name="set" type="boolean">Specifies whether the 'Keep Above' property was set or cleared.</param>
   <desc>Emitted whenever the client's 'Keep Above' property is set or cleared. 'set' is 1 if the client was set to 'Keep Above', 0 otherwise. Equivalent to workspace.clientSetKeepAbove, but for a specific client. Use wherever possible instead of workspace.clientSetKeepAbove to improve performance.</desc>
  </event>
  
  <method name="close">
   <desc>Closes the given client using killClient.</desc>
  </method>
  
  <event name="minimized" signal="s_minimized" wslot="DIRECT_CONNECTION" wsignal="minimized">
   <desc>Emitted whenever a client is minimized. Equivalent to workspace.clientMinimized, but for a specific client. Use wherever possible instead of workspace.clientMinimzed to improve performance.</desc>
  </event>
  
  <event name="maximizeSet" signal="maximizeSet" wslot="sl_maximizeSet" wsignal="maximizeSet">
   <param name="horizontally" type="boolean">(true) if the client was maximized horizontally, (false) otherwise.</param>
   <param name="vertically" type="boolean">(true) if the client was maximized vertically, (false) otherwise.</param>
   <desc>Emitted when the client is maximized in a particular orientation. The orientation i.e. the rectangular direction in which the client was specified to occupy the entire available space is specified by the two parameters horizontally and vertically. If both are true, the client was maximized fully i.e. asked to occupy the entire workspace are available. Equivalent to workspace.clientMaximizeSet, but for a specific client. Use wherever possible instead of workspace.clientMaximizeSet to improve performance.</desc>
  </event>
  
  <event name="activated" signal="s_activated" wslot="DIRECT_CONNECTION" wsignal="gotFocus">
   <desc>Emitted whenever the client is activated (or gets focus). Equivalent to workspace.clientActivated but for a specific client. Use wherever possible instead of workspace.clientActivated to improve performance.</desc>
  </event>
  
  <method name="move" vparamstyle="true">
   <paramset>
    <param name="location" type="qpoint">The (x, y) point to where the top left corner of the client must be moved to keeping the current height and width same.</param>
    <param name="emitjs" type="boolean">EmitJS value (defaults to true).</param>
   </paramset>
   
   <paramset>
    <param name="x" type="integer">The x co-ordinate value of the point to where the top left corner of the client must be moved to keeping the current height and width same.</param>
    <param name="x" type="integer">The y co-ordinate value of the point to where the top left corner of the client must be moved to keeping the current height and width same.</param>
    <param name="emitjs" type="boolean">EmitJS value (defaults to true).</param>
   </paramset>
   
   <desc>Moves the client to the specified location keeping the height and width of the client same.</desc>
  </method>
  
  <method name="resize" vparamstyle="true">
   <paramset>
    <param name="size" type="qsize">The size to which the client is to be resized.</param>
    <param name="emitJS" type="boolean">EmitJS value (defaults to true).</param>
   </paramset>
   
   <paramset>
    <param name="w" type="integer">New width for the client.</param>
    <param name="h" type="integer">New height for the client.</param>
    <param name="emitJS" type="boolean">EmitJS value (defaults to true).</param>
   </paramset>
   
   <desc>Resizes the client to the specified size without changing its position.</desc>
  </method>
  
  <method name="setGeometry" vparamstyle="true">
   <paramset>
    <param name="geometry" type="qrect">The new geometry which is to be set for the client.</param>
    <param name="emitJS" type="boolean">EmitJS value (defaults to true).</param>
   </paramset>
   
   <paramset>
    <param name="x" type="integer">The x co-ordinate of the new geometry.</param>
    <param name="y" type="integer">The y co-ordinate of the new geometry.</param>
    <param name="w" type="integer">The width of the new geometry.</param>
    <param name="h" type="integer">The height of the new geometry.</param>
   </paramset>
   
   <desc>Sets the geometry of the client i.e. sets is size and location according to the provided parameters.</desc>
  </method>
  
  <method name="getWindowInfo">
   <return type="windowinfo"></return>
   <desc>Returns a windowinfo object which can be used to get further information about the client. Wherever possible, directly use the client properties than calling for a windowinfo object. NOTE: The windowinfo object is a 'snapshot' object and hence the data provided by it is not modified when the properties of the client are changed.</desc>
  </method>
  
  <method name="isTransient">
   <return type="boolean"></return>
   <desc>Returns (true) is 'client' is transient, (false) otherwise.</desc>
  </method>
  
  <method name="isTransientFor">
   <return type="client"></return>
   <desc>If the given client is transient, returns it's parent client, otherwise returns an undefined scriptvalue.</desc>
  </method>
  
  <method name="activate">
   <desc>&lt;strong&gt;Attempt&lt;/strong&gt; to activate (focus) the client. By attempt, it means that focus stealing prevention still is activated and the rules for activation are in place. Hence, the client actually may nor may not be activated.</desc>
  </method>
  
  <method name="setCaption">
   <param name="caption_string" type="string">The caption to be set for the specified.</param>
   <desc>Sets the caption for the specified client to caption_string.</desc>
  </method>
  
  <method name="unminimize">
   <desc>Unminimizes (or restores) the given client.</desc>
  </method>
  
  <alias name="restore" of="unminimize"></alias>
  
  <event name="unminimized" signal="unminimized" wslot="DIRECT_CONNECTION" wsignal="unminimized">
   <desc>Emitted whenever the given client is unminimized. Equivalent of workspace.clientUnminimzed but for a specific client. Use wherever possible instead of workspace.clientUnminimized to improve performance.</desc>
  </event>
  
  <alias name="restored" of="unminimized"></alias>
  
  <method name="setFullScreen">
   <param type="fss_set">If (true), then the client is set to full screen or else, it is unset from fullscreen mode. If no parameter is provided, it toggles the full screen state.</param>
   <desc>Sets the client to or from full screen mode.</desc>
  </method>
  
  <method name="isShade">
   <return type="boolean"></return>
   <desc>Returns (true) if the client is shaded, (false) otherwise.</desc>
  </method>

  <method name="isShadeable">
   <return type="boolean"></return>
   <desc>Returns (true) if the client is shadeable (can be shaded), (false) otherwise.</desc>
  </method>

  <method name="isMinimized">
   <return type="boolean"></return>
   <desc>Returns (true) if the client is minimized, (false) otherwise.</desc>
  </method>

  <method name="isMinimizable">
   <return type="boolean"></return>
   <desc>Returns (true) if the client can be minimized, (false) otherwise.</desc>
  </method>

  <method name="isMaximizable">
   <return type="boolean"></return>
   <desc>Returns (true) if the client can be mazimized, (false) otherwise.</desc>
  </method>

  <method name="isResizable">
   <return type="boolean"></return>
   <desc>Returns (true) if the client can be resized (changable size), (false) otherwise.</desc>
  </method>

  <method name="isMovable">
   <return type="boolean"></return>
   <desc>Returns (true) if the client can be moved (non-fixed location), (false) otherwise.</desc>
  </method>

  <method name="isMovableAcrossScreens">
   <return type="boolean"></return>
   <desc>Returns (true) if the client can be moved across screens (only valid in a multiple monitor setup), (false) otherwise.</desc>
  </method>

  <method name="isCloseable">
   <return type="boolean"></return>
   <desc>Returns (true) if the client can be closed by user action (or any other action other than the system or the application itself), (false) otherwise.</desc>
  </method>

  <method name="isFullScreen">
   <return type="boolean"></return>
   <desc>Returns (true) if the client is in fullscreen mode, (false) otherwise.</desc>
  </method>

  <method name="isFullScreenable">
   <return type="boolean"></return>
   <desc>Returns (true) if the client can be set to fullscreen mode, (false) otherwise.</desc>
  </method>
  
  <method name="isNormal">
   <return type="boolean"></return>
   <desc>Returns (true) if the window is 'normal', (false) otherwise. A normal window is a window which has a border, can be moved by the user, can be closed, etc.</desc>
  </method>
  
  <method name="keepAbove">
   <return type="boolean"></return>
   <desc>Returns (true) if 'Keep Above Others' has been set on the client, (false) otherwise.</desc>
  </method>
  
  <method name="keepBelow">
   <return type="boolean"></return>
   <desc>Returns (true) if 'Keep Below Others' has been set on the client, (false) otherwise.</desc>
  </method>
  
  <method name="setKeepAbove">
   <param name="keepabove" type="boolean">The 'Keep Above others' parameter to be applied to the client</param>
   <desc>Sets the 'Keep Above others' parameter value or unsets it according to keepabove.</desc>
  </method>
  
  <method name="setKeepBelow" type="boolean">
   <param name="keepbelow">The 'Keep Below others' parameter to be applied to the client</param>
   <desc>Sets the 'Keep Below others' parameter value or unsets it according to keepbelow.</desc>
  </method>
  
  <method name="clientGroup">
   <return type="clientgroup"></return>
   <desc>Returns the client group the client belongs to. If it belongs to no client, it returns an undefined script value.</desc>
  </method>
  
  <event name="fullScreenSet" signal="s_fullScreenSet" wslot="DIRECT_CONNECTION" wsignal="fullScreenSet">
   <param name="fss_set" type="boolean">(true) if the client was set to full screen mode, (false) if the client was set from full screen mode.</param>
   <desc>Emitted whenever the client's fullscreen mode is toggled. fss_set specifies whether the client was set to or from fullscreen mode.</desc>
  </event>
  
  <method name="desktop">
   <return type="integer"></return>
   <desc>Returns the desktop number that the client is on. If it is on all desktops, it returns -1.</desc>
  </method>
 </class>
 
 <class name="clientgroup" type="instantiable">
  <method name="ClientGroup" constructor="true">
   <param name="seed_client" type="client">The client to be added to the newly formed clientgroup. This is a mandatory argument for the creation of a new clientgroup object.</param>
   <desc>Creates a new clientgroup object. A clientgroup in essence refers to a group of tabbed clients and an object refers to a specific group of such tabbed clients. It returns a clientgroup object which can be then manipulated using the various accessor functions.</desc>
  </method>
  
  <method name="add">
   <param name="new_client" type="client">A client object to be added to the clientgroup.</param>
   <param name="beforeClient" type="integer">An index as to where the client is to be added to the clientgroup. It is an optional argument and if not specified, it will be added at the last position in the clientgroup.</param>
   <param name="becomeVisible" type="boolean">If (true), makes the added client visible.</param>
   
   <desc>Adds new_client to the clientgroup at the index specified by beforeClient and if becomeVisible is true, makes it visible.</desc>
  </method>
  
  <method name="remove" vparamstyle="true">
   <paramset>
    <param name="index" type="integer">The client index which is to be removed.</param>
    <param name="set_geom" type="qrect">The geometry to be set after removeal. This parameter is optional.</param>
   </paramset>
   
   <paramset>
    <param name="rem_client" type="client">The client which is to be removed.</param>
    <param name="set_geom" type="qrect">The geometry to be set after removal.</param>
   </paramset>
   
   <desc>Removes the client from the clientgroup and then sets it's geometry according to set_geom. This parameter is optional.</desc>
  </method>
  
  <method name="clients">
   <return type="Array(client)"></return>
   <desc>Returns an array of all the member clients of the clientgroup.</desc>
  </method>
  
  <method name="contains">
   <return type="boolean"></return>
   <param name="needle_client" type="client">The client to be searched for</param>
   <desc>Returns (true) if needle_client is a member of the clientgroup, (false) otherwise.</desc>
  </method>
  
  <method name="indexOf">
   <return type="integer"></return>
   <param name="needle_client" type="client">The client whose index is to be found</param>
   <desc>Searches for needle_client in the clientgroup and returns the position at which it exists. If needle_client is not found, then it returns -1.</desc>
  </method>
  
  <method name="move" vparamstyle="true">
   <paramset>
    <param name="index_a" type="integer">The index of the client to be moved.</param>
    <param name="index_b" type="integer">The index of the position to move the client to.</param>
   </paramset>
   
   <paramset>
    <param name="move_client" type="integer">The client to be moved.</param>
    <param name="index" type="integer">The index of the position to move the client to.</param>
   </paramset>
   
   <paramset>
    <param name="move_client" type="integer">The client to be moved.</param>
    <param name="before_client" type="integer">The client before which the client is to moved.</param>
   </paramset>
   
   <paramset>
    <param name="index_a" type="integer">The index of the client to be moved.</param>
    <param name="before_client" type="integer">The client before which the client is to moved.</param>
   </paramset>
   
   <desc>Move a client within the group. Accepts move(client, client), move(index, index), move(index, client), move(client, index). All calls except move(client, client) are eventually mapped to move(index, index) using indexOf(client)</desc>
  </method>
  
  <method name="removeAll">
   <desc>Removes all the clients from the clientgroup i.e. completely disassembles the clientgroup into its proponents.</desc>
  </method>
  
  <method name="closeAll">
   <desc>Closes all the clients presents in the clientgroup.</desc>
  </method>
  
  <method name="minSize">
   <return type="qsize"></return>
   <desc>Returns the minimum size acceptable for the clientgroup computed from the minimum sizes of all its present members.</desc>
  </method>
  
  <method name="maxSize">
   <return type="qsize"></return>
   <desc>Returns the maximum size acceptable for the clientgroup computed from the minimum sizes of all its present members.</desc>
  </method>
 </class>

 <class name="windowinfo" type="floating">
  <property name="isValid" type="GO">
   <return type="boolean"></return>
   <desc>Returns (true) if the client is valid, (false) otherwise.</desc>
  </property>

  <property name="visibleName" type="GO">
   <return type="string"></return>
   <desc>Returns the visible name of the client.</desc>
  </property>

  <property name="isMinimized" type="GO">
   <return type="boolean"></return>
   <desc>Returns (true) if client is minimized. Redundant with client.isMinimized. For client, the subclass property is called, not the toplevel one.</desc>
  </property>

  <property name="state" type="GO">
   <return type="integer"></return>
   <desc>Returns an integeral state for the client. Prefer other methods like isShaded, isFullScreenSet etc. over this.</desc>
  </property>

  <property name="windowRole" type="GO">
   <return type="string"></return>
   <desc>Returns the window role of the toplevel client.</desc>
  </property>

  <property name="windowClassClass" type="GO">
   <return type="string"></return>
   <desc>Returns the windowclass class of the client.</desc>
  </property>

  <property name="windowClassName" type="GO">
   <return type="string"></return>
   <desc>Returns the windowclass name of the client.</desc>
  </property>
 </class>
 
 <class name="config" type="singleton">
  <property name="loaded" type="GO">
   <return type="boolean"></return>
   <desc>Returns (true) if a configuration file was found and loaded, (false) otherwise.</desc>
  </property>
  
  <method name="exists">
   <param name="config_key" type="string">The configuration key to be seeked.</param>
   <desc>Searches for config_key in the configuration array and returns (true) if a corresponding value exists, (false) otherwise.</desc>
  </method>
  
  <method name="get" vparamstyle="true">
   <paramset>
   </paramset>
   
   <paramset>
    <param name="key1, key2 ... keyN" type="string">A list of keys to search the values for.</param>
   </paramset>
   
   <paramset>
    <param name="key" type="string">The key to search the value for.</param>
   </paramset>
   
   <paramset>
    <param name="keyArray" type="Array(string)">An array of keys to search the corresponding values for.</param>
    <param name="showNonAssoc" type="boolean">If (true) causes the function to return an integer-indexed array, otherwise returns an associative array in the form ["key" : "value"]. This parameter is optional, defaults to false</param>
   </paramset>
   
   <desc>If called without parameters, returns an associative array in the format ["key" : "value"] of all available key value pairs. If only a single key is requested for (passing 1 string parameter), then the corresponding value is returned and NOT an array. If multiple keys are provided as multiple arguments, an associative array is returned. If multiple keys (or a single) key is provided as an Array, then an associative array is present (if showNonAssoc is false or it is not specified), otherwise returns an integer indexed array.</desc>
  </method>
 </class>
</root>
