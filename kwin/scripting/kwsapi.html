<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml/" lang="en" xml:lang="en">
 <head>
  <title>KWinScripting :: APIDoX</title>
  <link rel="stylesheet" href="apistyle.css" type="text/css" media="screen" />
 </head>

 <body>
  <div id="root">
   <div id="class_workspace" class="classes">
    <h2>workspace<sup>[<em>singleton</em>]</sup></h2>
    <div id="events_workspace" class="events">
     <h3>Events</h3>
     <div class="event">
      <h4>workspace.currentDesktopChanged</h4>
      <p class="desc">Emitted when the user switches from a virtual desktop to another.</p>
      <ul>
       <li><strong>old_desk {integer}</strong>: The number of the virtual desktop the user switched from.</li>
      </ul>
     </div>
     <div class="event">
      <h4>workspace.desktopPresenceChanged</h4>
      <p class="desc">Emitted whenever a client is moved across virtual desktops. The client's previous desktop is available through the old_desk parameter, whereas the current desktop can be fetched using moved_client.desktop</p>
      <ul>
       <li><strong>moved_client {client}</strong>: The client which was moved from desktop old_desk to the new one</li>
       <li><strong>old_desk {integer}</strong>: The previous desktop on which the client was present</li>
      </ul>
     </div>
     <div class="event">
      <h4>workspace.clientAdded</h4>
      <p class="desc">Emitted whenever a new client is added to the workspace. This generally occurs when a new window is opened which includes dialog boxes, windows etc. However, it is NOT emitted for unmanaged clients like the Alt+Tab switcher.</p>
      <ul>
       <li><strong>added_client {client}</strong>: The client which was added.</li>
      </ul>
     </div>
     <div class="event">
      <h4>workspace.clientManaging</h4>
      <p class="desc">Emitted whenever a client is being managed by the KWin subsystem. The difference between workspace.clientManaging and workspace.clientAdded is that clientManaging is emitted BEFORE clientAdded. Also, if KWin is restarted with a list of clients C, then the clientManaging event will be emitted for every client in C, but clientAdded will not.</p>
      <ul>
       <li><strong>managing_client {client}</strong>: The client which is being managed.</li>
      </ul>
     </div>
     <div class="event">
      <h4>workspace.clientMinimized</h4>
      <p class="desc">Emitted whenever a client is minimized.</p>
      <ul>
       <li><strong>minimized_client {client}</strong>: The client which was minimized.</li>
      </ul>
     </div>
     <div class="event">
      <h4>workspace.clientMaximizeSet</h4>
      <p class="desc">Emitted whenever a client is maximized in a particular orientation. The orientation i.e. the rectangular direction in which the client was specified to occupy the entire available space is specified by the two parameters horizontally and vertically. If both are true, the client was maximized fully i.e. asked to occupy the entire workspace are available.</p>
      <ul>
       <li><strong>maximized_client {client}</strong>: The client which was maximized (in a certain orientation).</li>
       <li><strong>horizontally {boolean}</strong>: (true) if the client was maximized horizontally, (false) otherwise.</li>
       <li><strong>vertically {boolean}</strong>: (true) if the client was maximized vertically, (false) otherwise.</li>
      </ul>
     </div>
     <div class="event">
      <h4>workspace.killWindowCalled</h4>
      <p class="desc">Emitted whenever the user requests a Kill Window [generally using the Ctrl+Esc combination]. The parameter killwindow_client is not completely safe and may return kill windows out of order of invocation. This is just a fancy function, avoid using. Instead, use workspace.clientAdded and filter for incoming Kill Windows.</p>
      <ul>
       <li><strong>killwindow_client {client}</strong>: The client handle to the kill window that was called.</li>
      </ul>
     </div>
     <div class="event">
      <h4>workspace.clientActivated</h4>
      <p class="desc">Emitted whenever a client is given focus or 'activated'.</p>
      <ul>
       <li><strong>activated_client {client}</strong>: The client which was activated (or received focus).</li>
      </ul>
     </div>
     <div class="event">
      <h4>workspace.clientFullScreenSet</h4>
      <p class="desc">Emitted whenever a client is set to full screen or unset. The fss_set parameter can be used to determine whether the client was set or unset.</p>
      <ul>
       <li><strong>fss_set {boolean}</strong>: (true) if the client was switched to full screen mode, (false) if it was switched from full screen mode.</li>
       <li><strong>fss_client {client}</strong>: The client which was set/unset to fullscreen.</li>
      </ul>
     </div>
     <div class="event">
      <h4>workspace.clientUnminimized</h4>
      <p class="desc">Emitted whenever a client is Unminimized (or restored).</p>
      <ul>
       <li><strong>unm_client {client}</strong>: The client which was unminimzed.</li>
      </ul>
     </div>
   </div>
    <div id="method_workspace" class="methods">
     <h3>Methods</h3>
     <div class="method">
      <h4>workspace.getAllClients[ret: Array(client)] </h4>
      <ul>
       <li>workspace.getAllClients(desktop_no {integer})</li>
      </ul>
      <p class="desc">Gets all clients on the virtual desktop desktop_no. If no desktop number is specified then it fetches all the clients. To specifically isolate clients which are on 'All desktops', set the desktop_no parameter to -1.</p>
       <p class="footdocs">getAllClients(desktop_no {integer})<br />
        <ul>
         <li><strong>desktop_no {integer}</strong>: The desktop number belonging to which the clients are to be fetched.</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>workspace.dimensions[ret: qsize] </h4>
      <ul>
       <li>workspace.dimensions()</li>
      </ul>
      <p class="desc">Returns the dimensions of the workspace in pixels.</p>
     </div>
     <div class="method">
      <h4>workspace.desktopGridSize[ret: qsize] </h4>
      <ul>
       <li>workspace.desktopGridSize()</li>
      </ul>
      <p class="desc">Returns the desktop size in grid units. In essence, it returns the order of a rectangular matrix, where each element is a virtual desktop and the rows and columns specify the number of virtual desktops and the way of arrangement.</p>
     </div>
     <div class="method">
      <h4>workspace.activeClient[ret: client] </h4>
      <ul>
       <li>workspace.activeClient()</li>
      </ul>
      <p class="desc">Returns the client which currently has focus.</p>
     </div>
     <div class="method">
      <h4>workspace.clientGroups[ret: Array(clientgroup)] </h4>
      <ul>
       <li>workspace.clientGroups()</li>
      </ul>
      <p class="desc">Returns an array of all the ClientGroups from the current workspace.</p>
     </div>
   </div>
    <div id="props_workspace" class="props">
     <h3>Properties</h3>
     <div class="prop">
      <h4>workspace.currentDesktop [ret: integer] <sup>[GO]</sup></h4>
      <p class="desc">Returns the current desktop number of the workspace.</p>
     </div>
   </div>
   </div>
   <div id="class_toplevel" class="classes">
    <h2>toplevel<sup>[<em>floating</em>]</sup></h2>
    <div id="method_toplevel" class="methods">
     <h3>Methods</h3>
     <div class="method">
      <h4>toplevel.x[ret: integer] </h4>
      <ul>
       <li>toplevel.x()</li>
      </ul>
      <p class="desc">Returns the x co-ordinate of the toplevel client (or the client).</p>
     </div>
     <div class="method">
      <h4>toplevel.y[ret: integer] </h4>
      <ul>
       <li>toplevel.y()</li>
      </ul>
      <p class="desc">Returns the y co-ordinate of the toplevel client (or the client).</p>
     </div>
     <div class="method">
      <h4>toplevel.width[ret: integer] </h4>
      <ul>
       <li>toplevel.width()</li>
      </ul>
      <p class="desc">Returns the width of the toplevel client (or the client).</p>
     </div>
     <div class="method">
      <h4>toplevel.height[ret: integer] </h4>
      <ul>
       <li>toplevel.height()</li>
      </ul>
      <p class="desc">Returns the height of the toplevel client (or the client).</p>
     </div>
     <div class="method">
      <h4>toplevel.size[ret: qsize] </h4>
      <ul>
       <li>toplevel.size()</li>
      </ul>
      <p class="desc">Returns the size of the toplevel client (or the client).</p>
     </div>
     <div class="method">
      <h4>toplevel.pos[ret: qpoint] </h4>
      <ul>
       <li>toplevel.pos()</li>
      </ul>
      <p class="desc">Returns the position of the toplevel client (or the client).</p>
     </div>
     <div class="method">
      <h4>toplevel.opacity[ret: decimal] </h4>
      <ul>
       <li>toplevel.opacity()</li>
      </ul>
      <p class="desc">Returns the opacity (or 1 - transperency) of the toplevel client (or the client).</p>
     </div>
     <div class="method">
      <h4>toplevel.hasAlpha[ret: bool] </h4>
      <ul>
       <li>toplevel.hasAlpha()</li>
      </ul>
      <p class="desc">Returns (true) if the client can be made translucent i.e. opacity can be set to values other than 0 or 1, (false) otherwise. NOTE: If compositing is OFF, then clients may still show that translucency is possible, but translucency is not possible without compositing being ON.</p>
     </div>
     <div class="method">
      <h4>toplevel.setOpacity</h4>
      <ul>
       <li>toplevel.setOpacity(opacity_v {decimal})</li>
      </ul>
      <p class="desc">Sets the opacity of the client to opacity_v or sets transperency to (1 - opacity_v). NOTE: If compositing is OFF, this function has no effect for any values between 0 and 1 (exclusive).</p>
       <p class="footdocs">setOpacity(opacity_v {decimal})<br />
        <ul>
         <li><strong>opacity_v {decimal}</strong>: The opacity to be set (on a scale of 0-1).</li>
        </ul>
       </p>
     </div>
   </div>
   </div>
   <div id="class_client" class="classes">
    <h2>client<sup>[<em>floating</em>]</sup></h2>
    <div id="events_client" class="events">
     <h3>Events</h3>
     <div class="event">
      <h4>client.clientMoved</h4>
      <p class="desc">Emitted whenever the client is moved or it's geometry changed. This includes when a client is resized.</p>
     </div>
     <div class="event">
      <h4>client.minimized</h4>
      <p class="desc">Emitted whenever a client is minimized. Equivalent to workspace.clientMinimized, but for a specific client. Use wherever possible instead of workspace.clientMinimzed to improve performance.</p>
     </div>
     <div class="event">
      <h4>client.maximizeSet</h4>
      <p class="desc">Emitted when the client is maximized in a particular orientation. The orientation i.e. the rectangular direction in which the client was specified to occupy the entire available space is specified by the two parameters horizontally and vertically. If both are true, the client was maximized fully i.e. asked to occupy the entire workspace are available. Equivalent to workspace.clientMaximizeSet, but for a specific client. Use wherever possible instead of workspace.clientMaximizeSet to improve performance.</p>
      <ul>
       <li><strong>horizontally {boolean}</strong>: (true) if the client was maximized horizontally, (false) otherwise.</li>
       <li><strong>vertically {boolean}</strong>: (true) if the client was maximized vertically, (false) otherwise.</li>
      </ul>
     </div>
     <div class="event">
      <h4>client.activated</h4>
      <p class="desc">Emitted whenever the client is activated (or gets focus). Equivalent to workspace.clientActivated but for a specific client. Use wherever possible instead of workspace.clientActivated to improve performance.</p>
     </div>
     <div class="event">
      <h4>client.unminimized</h4>
      <p class="desc">Emitted whenever the given client is unminimized. Equivalent of workspace.clientUnminimzed but for a specific client. Use wherever possible instead of workspace.clientUnminimized to improve performance.</p>
     </div>
     <div class="event">
      <h4>client.fullScreenSet</h4>
      <p class="desc">Emitted whenever the client's fullscreen mode is toggled. fss_set specifies whether the client was set to or from fullscreen mode.</p>
      <ul>
       <li><strong>fss_set {boolean}</strong>: (true) if the client was set to full screen mode, (false) if the client was set from full screen mode.</li>
      </ul>
     </div>
   </div>
    <div id="method_client" class="methods">
     <h3>Methods</h3>
     <div class="method">
      <h4>client.caption[ret: string] </h4>
      <ul>
       <li>client.caption()</li>
      </ul>
      <p class="desc">Returns the caption of the caption (or the title) of the window.</p>
     </div>
     <div class="method">
      <h4>client.close</h4>
      <ul>
       <li>client.close()</li>
      </ul>
      <p class="desc">Closes the given client using killClient.</p>
     </div>
     <div class="method">
      <h4>client.move<sup>[variable parameter styles]</sup></h4>
      <ul>
       <li>client.move(location {qpoint}, emitjs {boolean})</li>
       <li>client.move(x {integer}, x {integer}, emitjs {boolean})</li>
      </ul>
      <p class="desc">Moves the client to the specified location keeping the height and width of the client same.</p>
       <p class="footdocs">move(location {qpoint}, emitjs {boolean})<br />
        <ul>
         <li><strong>location {qpoint}</strong>: The (x, y) point to where the top left corner of the client must be moved to keeping the current height and width same.</li>
         <li><strong>emitjs {boolean}</strong>: EmitJS value (defaults to true).</li>
        </ul>
       </p>
       <p class="footdocs">move(x {integer}, x {integer}, emitjs {boolean})<br />
        <ul>
         <li><strong>x {integer}</strong>: The x co-ordinate value of the point to where the top left corner of the client must be moved to keeping the current height and width same.</li>
         <li><strong>x {integer}</strong>: The y co-ordinate value of the point to where the top left corner of the client must be moved to keeping the current height and width same.</li>
         <li><strong>emitjs {boolean}</strong>: EmitJS value (defaults to true).</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>client.resize<sup>[variable parameter styles]</sup></h4>
      <ul>
       <li>client.resize(size {qsize}, emitJS {boolean})</li>
       <li>client.resize(w {integer}, h {integer}, emitJS {boolean})</li>
      </ul>
      <p class="desc">Resizes the client to the specified size without changing its position.</p>
       <p class="footdocs">resize(size {qsize}, emitJS {boolean})<br />
        <ul>
         <li><strong>size {qsize}</strong>: The size to which the client is to be resized.</li>
         <li><strong>emitJS {boolean}</strong>: EmitJS value (defaults to true).</li>
        </ul>
       </p>
       <p class="footdocs">resize(w {integer}, h {integer}, emitJS {boolean})<br />
        <ul>
         <li><strong>w {integer}</strong>: New width for the client.</li>
         <li><strong>h {integer}</strong>: New height for the client.</li>
         <li><strong>emitJS {boolean}</strong>: EmitJS value (defaults to true).</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>client.setGeometry<sup>[variable parameter styles]</sup></h4>
      <ul>
       <li>client.setGeometry(geometry {qrect}, emitJS {boolean})</li>
       <li>client.setGeometry(x {integer}, y {integer}, w {integer}, h {integer})</li>
      </ul>
      <p class="desc">Sets the geometry of the client i.e. sets is size and location according to the provided parameters.</p>
       <p class="footdocs">setGeometry(geometry {qrect}, emitJS {boolean})<br />
        <ul>
         <li><strong>geometry {qrect}</strong>: The new geometry which is to be set for the client.</li>
         <li><strong>emitJS {boolean}</strong>: EmitJS value (defaults to true).</li>
        </ul>
       </p>
       <p class="footdocs">setGeometry(x {integer}, y {integer}, w {integer}, h {integer})<br />
        <ul>
         <li><strong>x {integer}</strong>: The x co-ordinate of the new geometry.</li>
         <li><strong>y {integer}</strong>: The y co-ordinate of the new geometry.</li>
         <li><strong>w {integer}</strong>: The width of the new geometry.</li>
         <li><strong>h {integer}</strong>: The height of the new geometry.</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>client.getWindowInfo[ret: windowinfo] </h4>
      <ul>
       <li>client.getWindowInfo()</li>
      </ul>
      <p class="desc">Returns a windowinfo object which can be used to get further information about the client. Wherever possible, directly use the client properties than calling for a windowinfo object. NOTE: The windowinfo object is a 'snapshot' object and hence the data provided by it is not modified when the properties of the client are changed.</p>
     </div>
     <div class="method">
      <h4>client.isTransient[ret: boolean] </h4>
      <ul>
       <li>client.isTransient()</li>
      </ul>
      <p class="desc">Returns (true) is 'client' is transient, (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isTransientFor[ret: client] </h4>
      <ul>
       <li>client.isTransientFor()</li>
      </ul>
      <p class="desc">If the given client is transient, returns it's parent client, otherwise returns an undefined scriptvalue.</p>
     </div>
     <div class="method">
      <h4>client.activate</h4>
      <ul>
       <li>client.activate()</li>
      </ul>
      <p class="desc"><strong>Attempt</strong> to activate (focus) the client. By attempt, it means that focus stealing prevention still is activated and the rules for activation are in place. Hence, the client actually may nor may not be activated.</p>
     </div>
     <div class="method">
      <h4>client.setCaption</h4>
      <ul>
       <li>client.setCaption(caption_string {string})</li>
      </ul>
      <p class="desc">Sets the caption for the specified client to caption_string.</p>
       <p class="footdocs">setCaption(caption_string {string})<br />
        <ul>
         <li><strong>caption_string {string}</strong>: The caption to be set for the specified.</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>client.unminimize</h4>
      <ul>
       <li>client.unminimize()</li>
      </ul>
      <p class="desc">Unminimizes (or restores) the given client.</p>
     </div>
     <div class="method">
      <h4>client.setFullScreen</h4>
      <ul>
       <li>client.setFullScreen( {fss_set})</li>
      </ul>
      <p class="desc">Sets the client to or from full screen mode.</p>
       <p class="footdocs">setFullScreen( {fss_set})<br />
        <ul>
         <li><strong> {fss_set}</strong>: If (true), then the client is set to full screen or else, it is unset from fullscreen mode. If no parameter is provided, it toggles the full screen state.</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>client.isShade[ret: boolean] </h4>
      <ul>
       <li>client.isShade()</li>
      </ul>
      <p class="desc">Returns (true) if the client is shaded, (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isShadeable[ret: boolean] </h4>
      <ul>
       <li>client.isShadeable()</li>
      </ul>
      <p class="desc">Returns (true) if the client is shadeable (can be shaded), (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isMinimized[ret: boolean] </h4>
      <ul>
       <li>client.isMinimized()</li>
      </ul>
      <p class="desc">Returns (true) if the client is minimized, (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isMinimizable[ret: boolean] </h4>
      <ul>
       <li>client.isMinimizable()</li>
      </ul>
      <p class="desc">Returns (true) if the client can be minimized, (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isMaximizable[ret: boolean] </h4>
      <ul>
       <li>client.isMaximizable()</li>
      </ul>
      <p class="desc">Returns (true) if the client can be mazimized, (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isResizable[ret: boolean] </h4>
      <ul>
       <li>client.isResizable()</li>
      </ul>
      <p class="desc">Returns (true) if the client can be resized (changable size), (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isMovable[ret: boolean] </h4>
      <ul>
       <li>client.isMovable()</li>
      </ul>
      <p class="desc">Returns (true) if the client can be moved (non-fixed location), (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isMovableAcrossScreens[ret: boolean] </h4>
      <ul>
       <li>client.isMovableAcrossScreens()</li>
      </ul>
      <p class="desc">Returns (true) if the client can be moved across screens (only valid in a multiple monitor setup), (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isCloseable[ret: boolean] </h4>
      <ul>
       <li>client.isCloseable()</li>
      </ul>
      <p class="desc">Returns (true) if the client can be closed by user action (or any other action other than the system or the application itself), (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isFullScreen[ret: boolean] </h4>
      <ul>
       <li>client.isFullScreen()</li>
      </ul>
      <p class="desc">Returns (true) if the client is in fullscreen mode, (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isFullScreenable[ret: boolean] </h4>
      <ul>
       <li>client.isFullScreenable()</li>
      </ul>
      <p class="desc">Returns (true) if the client can be set to fullscreen mode, (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.isNormal[ret: boolean] </h4>
      <ul>
       <li>client.isNormal()</li>
      </ul>
      <p class="desc">Returns (true) if the window is 'normal', (false) otherwise. A normal window is a window which has a border, can be moved by the user, can be closed, etc.</p>
     </div>
     <div class="method">
      <h4>client.keepAbove[ret: boolean] </h4>
      <ul>
       <li>client.keepAbove()</li>
      </ul>
      <p class="desc">Returns (true) if 'Keep Above Others' has been set on the client, (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.keepBelow[ret: boolean] </h4>
      <ul>
       <li>client.keepBelow()</li>
      </ul>
      <p class="desc">Returns (true) if 'Keep Below Others' has been set on the client, (false) otherwise.</p>
     </div>
     <div class="method">
      <h4>client.setKeepAbove</h4>
      <ul>
       <li>client.setKeepAbove(keepabove {})</li>
      </ul>
      <p class="desc">Sets the 'Keep Above others' parameter value or unsets it according to keepabove.</p>
       <p class="footdocs">setKeepAbove(keepabove {})<br />
        <ul>
         <li><strong>keepabove {}</strong>: The 'Keep Above others' parameter to be applied to the client</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>client.setKeepBelow</h4>
      <ul>
       <li>client.setKeepBelow(keepbelow {})</li>
      </ul>
      <p class="desc">Sets the 'Keep Below others' parameter value or unsets it according to keepbelow.</p>
       <p class="footdocs">setKeepBelow(keepbelow {})<br />
        <ul>
         <li><strong>keepbelow {}</strong>: The 'Keep Below others' parameter to be applied to the client</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>client.clientGroup[ret: clientgroup] </h4>
      <ul>
       <li>client.clientGroup()</li>
      </ul>
      <p class="desc">Returns the client group the client belongs to. If it belongs to no client, it returns an undefined script value.</p>
     </div>
     <div class="method">
      <h4>client.desktop[ret: integer] </h4>
      <ul>
       <li>client.desktop()</li>
      </ul>
      <p class="desc">Returns the desktop number that the client is on. If it is on all desktops, it returns -1.</p>
     </div>
   </div>
   </div>
   <div id="class_clientgroup" class="classes">
    <h2>clientgroup<sup>[<em>instantiable</em>]</sup></h2>
    <div id="method_clientgroup" class="methods">
     <h3>Methods</h3>
     <div class="method">
      <h4>clientgroup.ClientGroup<sup>[constructor]</sup></h4>
      <ul>
       <li>clientgroup.ClientGroup(seed_client {client})</li>
      </ul>
      <p class="desc">Creates a new clientgroup object. A clientgroup in essence refers to a group of tabbed clients and an object refers to a specific group of such tabbed clients. It returns a clientgroup object which can be then manipulated using the various accessor functions.</p>
       <p class="footdocs">ClientGroup(seed_client {client})<br />
        <ul>
         <li><strong>seed_client {client}</strong>: The client to be added to the newly formed clientgroup. This is a mandatory argument for the creation of a new clientgroup object.</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>clientgroup.add</h4>
      <ul>
       <li>clientgroup.add(new_client {client}, beforeClient {integer}, becomeVisible {boolean})</li>
      </ul>
      <p class="desc">Adds new_client to the clientgroup at the index specified by beforeClient and if becomeVisible is true, makes it visible.</p>
       <p class="footdocs">add(new_client {client}, beforeClient {integer}, becomeVisible {boolean})<br />
        <ul>
         <li><strong>new_client {client}</strong>: A client object to be added to the clientgroup.</li>
         <li><strong>beforeClient {integer}</strong>: An index as to where the client is to be added to the clientgroup. It is an optional argument and if not specified, it will be added at the last position in the clientgroup.</li>
         <li><strong>becomeVisible {boolean}</strong>: If (true), makes the added client visible.</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>clientgroup.remove<sup>[variable parameter styles]</sup></h4>
      <ul>
       <li>clientgroup.remove(index {integer}, set_geom {qrect})</li>
       <li>clientgroup.remove(rem_client {client}, set_geom {qrect})</li>
      </ul>
      <p class="desc">Removes the client from the clientgroup and then sets it's geometry according to set_geom. This parameter is optional.</p>
       <p class="footdocs">remove(index {integer}, set_geom {qrect})<br />
        <ul>
         <li><strong>index {integer}</strong>: The client index which is to be removed.</li>
         <li><strong>set_geom {qrect}</strong>: The geometry to be set after removeal. This parameter is optional.</li>
        </ul>
       </p>
       <p class="footdocs">remove(rem_client {client}, set_geom {qrect})<br />
        <ul>
         <li><strong>rem_client {client}</strong>: The client which is to be removed.</li>
         <li><strong>set_geom {qrect}</strong>: The geometry to be set after removal.</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>clientgroup.clients[ret: Array(client)] </h4>
      <ul>
       <li>clientgroup.clients()</li>
      </ul>
      <p class="desc">Returns an array of all the member clients of the clientgroup.</p>
     </div>
     <div class="method">
      <h4>clientgroup.contains[ret: boolean] </h4>
      <ul>
       <li>clientgroup.contains(needle_client {client})</li>
      </ul>
      <p class="desc">Returns (true) if needle_client is a member of the clientgroup, (false) otherwise.</p>
       <p class="footdocs">contains(needle_client {client})<br />
        <ul>
         <li><strong>needle_client {client}</strong>: The client to be searched for</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>clientgroup.indexOf[ret: integer] </h4>
      <ul>
       <li>clientgroup.indexOf(needle_client {client})</li>
      </ul>
      <p class="desc">Searches for needle_client in the clientgroup and returns the position at which it exists. If needle_client is not found, then it returns -1.</p>
       <p class="footdocs">indexOf(needle_client {client})<br />
        <ul>
         <li><strong>needle_client {client}</strong>: The client whose index is to be found</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>clientgroup.move<sup>[variable parameter styles]</sup></h4>
      <ul>
       <li>clientgroup.move(index_a {integer}, index_b {integer})</li>
       <li>clientgroup.move(move_client {integer}, index {integer})</li>
       <li>clientgroup.move(move_client {integer}, before_client {integer})</li>
       <li>clientgroup.move(index_a {integer}, before_client {integer})</li>
      </ul>
      <p class="desc">Move a client within the group. Accepts move(client, client), move(index, index), move(index, client), move(client, index). All calls except move(client, client) are eventually mapped to move(index, index) using indexOf(client)</p>
       <p class="footdocs">move(index_a {integer}, index_b {integer})<br />
        <ul>
         <li><strong>index_a {integer}</strong>: The index of the client to be moved.</li>
         <li><strong>index_b {integer}</strong>: The index of the position to move the client to.</li>
        </ul>
       </p>
       <p class="footdocs">move(move_client {integer}, index {integer})<br />
        <ul>
         <li><strong>move_client {integer}</strong>: The client to be moved.</li>
         <li><strong>index {integer}</strong>: The index of the position to move the client to.</li>
        </ul>
       </p>
       <p class="footdocs">move(move_client {integer}, before_client {integer})<br />
        <ul>
         <li><strong>move_client {integer}</strong>: The client to be moved.</li>
         <li><strong>before_client {integer}</strong>: The client before which the client is to moved.</li>
        </ul>
       </p>
       <p class="footdocs">move(index_a {integer}, before_client {integer})<br />
        <ul>
         <li><strong>index_a {integer}</strong>: The index of the client to be moved.</li>
         <li><strong>before_client {integer}</strong>: The client before which the client is to moved.</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>clientgroup.removeAll</h4>
      <ul>
       <li>clientgroup.removeAll()</li>
      </ul>
      <p class="desc">Removes all the clients from the clientgroup i.e. completely disassembles the clientgroup into its proponents.</p>
     </div>
     <div class="method">
      <h4>clientgroup.closeAll</h4>
      <ul>
       <li>clientgroup.closeAll()</li>
      </ul>
      <p class="desc">Closes all the clients presents in the clientgroup.</p>
     </div>
     <div class="method">
      <h4>clientgroup.minSize[ret: qsize] </h4>
      <ul>
       <li>clientgroup.minSize()</li>
      </ul>
      <p class="desc">Returns the minimum size acceptable for the clientgroup computed from the minimum sizes of all its present members.</p>
     </div>
     <div class="method">
      <h4>clientgroup.maxSize[ret: qsize] </h4>
      <ul>
       <li>clientgroup.maxSize()</li>
      </ul>
      <p class="desc">Returns the maximum size acceptable for the clientgroup computed from the minimum sizes of all its present members.</p>
     </div>
   </div>
   </div>
   <div id="class_windowinfo" class="classes">
    <h2>windowinfo<sup>[<em>floating</em>]</sup></h2>
    <div id="props_windowinfo" class="props">
     <h3>Properties</h3>
     <div class="prop">
      <h4>windowinfo.isValid [ret: boolean] <sup>[GO]</sup></h4>
      <p class="desc">Returns (true) if the client is valid, (false) otherwise.</p>
     </div>
     <div class="prop">
      <h4>windowinfo.visibleName [ret: string] <sup>[GO]</sup></h4>
      <p class="desc">Returns the visible name of the client.</p>
     </div>
     <div class="prop">
      <h4>windowinfo.isMinimized [ret: boolean] <sup>[GO]</sup></h4>
      <p class="desc">Returns (true) if client is minimized. Redundant with client.isMinimized. For client, the subclass property is called, not the toplevel one.</p>
     </div>
     <div class="prop">
      <h4>windowinfo.state [ret: integer] <sup>[GO]</sup></h4>
      <p class="desc">Returns an integeral state for the client. Prefer other methods like isShaded, isFullScreenSet etc. over this.</p>
     </div>
     <div class="prop">
      <h4>windowinfo.windowRole [ret: string] <sup>[GO]</sup></h4>
      <p class="desc">Returns the window role of the toplevel client.</p>
     </div>
     <div class="prop">
      <h4>windowinfo.windowClassClass [ret: string] <sup>[GO]</sup></h4>
      <p class="desc">Returns the windowclass class of the client.</p>
     </div>
     <div class="prop">
      <h4>windowinfo.windowClassName [ret: string] <sup>[GO]</sup></h4>
      <p class="desc">Returns the windowclass name of the client.</p>
     </div>
   </div>
   </div>
   <div id="class_config" class="classes">
    <h2>config<sup>[<em>singleton</em>]</sup></h2>
    <div id="method_config" class="methods">
     <h3>Methods</h3>
     <div class="method">
      <h4>config.exists</h4>
      <ul>
       <li>config.exists(config_key {string})</li>
      </ul>
      <p class="desc">Searches for config_key in the configuration array and returns (true) if a corresponding value exists, (false) otherwise.</p>
       <p class="footdocs">exists(config_key {string})<br />
        <ul>
         <li><strong>config_key {string}</strong>: The configuration key to be seeked.</li>
        </ul>
       </p>
     </div>
     <div class="method">
      <h4>config.get<sup>[variable parameter styles]</sup></h4>
      <ul>
       <li>config.get()</li>
       <li>config.get(key1, key2 ... keyN {string})</li>
       <li>config.get(key {string})</li>
       <li>config.get(keyArray {Array(string)}, showNonAssoc {boolean})</li>
      </ul>
      <p class="desc">If called without parameters, returns an associative array in the format ["key" : "value"] of all available key value pairs. If only a single key is requested for (passing 1 string parameter), then the corresponding value is returned and NOT an array. If multiple keys are provided as multiple arguments, an associative array is returned. If multiple keys (or a single) key is provided as an Array, then an associative array is present (if showNonAssoc is false or it is not specified), otherwise returns an integer indexed array.</p>
       <p class="footdocs">get(key1, key2 ... keyN {string})<br />
        <ul>
         <li><strong>key1, key2 ... keyN {string}</strong>: A list of keys to search the values for.</li>
        </ul>
       </p>
       <p class="footdocs">get(key {string})<br />
        <ul>
         <li><strong>key {string}</strong>: The key to search the value for.</li>
        </ul>
       </p>
       <p class="footdocs">get(keyArray {Array(string)}, showNonAssoc {boolean})<br />
        <ul>
         <li><strong>keyArray {Array(string)}</strong>: An array of keys to search the corresponding values for.</li>
         <li><strong>showNonAssoc {boolean}</strong>: If (true) causes the function to return an integer-indexed array, otherwise returns an associative array in the form ["key" : "value"]. This parameter is optional, defaults to false</li>
        </ul>
       </p>
     </div>
   </div>
    <div id="props_config" class="props">
     <h3>Properties</h3>
     <div class="prop">
      <h4>config.loaded [ret: boolean] <sup>[GO]</sup></h4>
      <p class="desc">Returns (true) if a configuration file was found and loaded, (false) otherwise.</p>
     </div>
   </div>
   </div>
  </div>
 </body>
</html>