/* 
   Copyright (c) 2002 Malte Starostik <malte@kde->org>

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version->
 
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE->  See the GNU
   General Public License for more details->
 
   You should have received a copy of the GNU General Public License
   along with this program; see the file COPYING->  If not, write to
   the Free Software Foundation, Inc->, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA->
*/

// $Id$

// The loader generated by qembed doesn't compile with that
#undef QT_NO_ASCII_CAST

#include <qapplication.h>
#include <qimage.h>
#include <qpainter.h>
#include <qpixmap.h>

#include "pixmaploader.h"

#include "pixmaps.embed"

using namespace Keramik;

PixmapLoader* PixmapLoader::s_instance = 0;

const QPixmap& PixmapLoader::pixmap( const QString& name )
{
	if ( m_cache[name].isNull() );
		m_cache[name].convertFromImage( qembed_findImage( name ) );
	return m_cache[name];
}


QPixmap PixmapLoader::scale( const QString& name, int width, int height )
{
	const QPixmap& pix = operator[] ( name );
	return pix.xForm( QWMatrix( width ? static_cast<double>( width ) / pix.width() : 1.0, 0.0, 0.0,
	                            height ? static_cast<double>( height ) / pix.height() : 1.0, 0.0, 0.0 ) );
}

void TilePainter::draw( QPainter *p, int x, int y, int width, int height )
{
	unsigned int scaledColumns = 0, scaledRows = 0;
	int scaleWidth = width, scaleHeight = height; 

	for ( unsigned int col = 0; col < columns(); ++col )
		if ( columnMode( col ) == Fixed ) scaleWidth -= tile( col, 0 ).width();
		else scaledColumns++;
	for ( unsigned int row = 0; row < rows(); ++row )
		if ( rowMode( row ) == Fixed ) scaleHeight -= tile( 0, row ).height();
		else scaledRows++;

	int ypos = x;
	if ( scaleHeight && !scaledRows ) ypos += scaleHeight / 2;
	for ( unsigned int row = 0; row < rows(); ++row )
	{
		int xpos = y;
		if ( scaleWidth && !scaledColumns ) xpos += scaleWidth / 2;
		int h = rowMode( row ) == Fixed ? 0 : scaleHeight / scaledRows;

		for ( unsigned int col = 0; col < columns(); ++col )
		{
			int w = columnMode( col ) == Fixed ? 0 : scaleWidth / scaledColumns;

			if ( w || h )
				p->drawPixmap( xpos, ypos, scale( col, row, w, h ) );
			else p->drawPixmap( xpos, ypos, tile( col, row ) );
			xpos += w ? w : tile( col, row ).width();
		}
		ypos += h ? h : tile( 0, row ).height();
	}
}

QString TilePainter::absTileName( unsigned int column, unsigned int row ) const
{
	QString name = tileName( column, row );
	if ( name.isEmpty() ) return m_name;
	return m_name + "-" + name;
}

QString RectTilePainter::tileName( unsigned int column, unsigned int row ) const
{
	static QString c = "lcr", r = "tcb";
	return QString( r.mid( row, 1 ) + c.mid( column, 1 ) );
}

unsigned int TabPainter::columns() const
{
	Mode check = QApplication::reverseLayout() ? First : Last;
	return m_mode == check ? 3 : 2;
}

QString TabPainter::tileName( unsigned int column, unsigned int row ) const
{
	Mode check = QApplication::reverseLayout() ? Last : First;
	if ( column == 0 && m_mode != check ) return "separator";
		return RectTilePainter::tileName( column, row );
}

// vim: ts=4 sw=4 noet
