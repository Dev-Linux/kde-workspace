/* 
   Copyright (c) 2002 Malte Starostik <malte@kde->org>

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version->
 
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE->  See the GNU
   General Public License for more details->
 
   You should have received a copy of the GNU General Public License
   along with this program; see the file COPYING->  If not, write to
   the Free Software Foundation, Inc->, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA->
*/

// $Id$

// The loader generated by qembed doesn't compile with that
#undef QT_NO_ASCII_CAST

#include <qapplication.h>
#include <qimage.h>
#include <qpainter.h>
#include <qpixmap.h>
#include <qpixmapcache.h>

#include "pixmaploader.h"

#include "pixmaps.embed"

using namespace Keramik;

PixmapLoader* PixmapLoader::s_instance = 0;

PixmapLoader::PixmapLoader()
	:m_cache( 193 ) 
{ 
	s_instance = this; 
	QPixmapCache::setCacheLimit( 128 );
	m_cache.setAutoDelete( true );
}

QPixmap PixmapLoader::pixmap( const QString& name )
{
	QPixmap result;
	if ( QPixmapCache::find( name, result ) )
		return result;

	QImage* img = m_cache[ name ];
	if ( !img ) {
		img = new QImage( qembed_findImage( name ) );
		m_cache.insert( name, img );
	}
	result.convertFromImage( *img );
	QPixmapCache::insert( name, result );
	return result;
}


QPixmap PixmapLoader::scale( const QString& name, int width, int height )
{
	QString key = name + '-' + QString::number( width ) + '-' + QString::number( height );
	QPixmap result;
	if ( QPixmapCache::find( key, result  ) )
		return result;

	QImage* img = m_cache[ name ];
	if ( !img ) {
		img = new QImage( qembed_findImage( name ) );
		m_cache.insert( name, img );
	}

	result.convertFromImage( img->scale( width ? width : img->width(), height ? height : img->height() ) );
	QPixmapCache::insert( key, result );
	return result;
}

void TilePainter::draw( QPainter *p, int x, int y, int width, int height )
{
	unsigned int scaledColumns = 0, scaledRows = 0, lastScaledColumn = 0, lastScaledRow = 0;
	int scaleWidth = width, scaleHeight = height;

	for ( unsigned int col = 0; col < columns(); ++col )
		if ( columnMode( col ) == Scaled )
		{
			scaledColumns++;
			lastScaledColumn = col;
		}
		else scaleWidth -= tile( col, 0 ).width();
	for ( unsigned int row = 0; row < rows(); ++row )
		if ( rowMode( row ) == Scaled )
		{
			scaledRows++;
			lastScaledRow = row;
		}
		else scaleHeight -= tile( 0, row ).height();

	int ypos = y;
	if ( scaleHeight && !scaledRows ) ypos += scaleHeight / 2;
	for ( unsigned int row = 0; row < rows(); ++row )
	{
		int xpos = x;
		if ( scaleWidth && !scaledColumns ) xpos += scaleWidth / 2;
		int h = rowMode( row ) == Fixed ? 0 : scaleHeight / scaledRows;
		if ( scaledRows && row == lastScaledRow ) h += scaleHeight - scaleHeight / scaledRows * scaledRows;

		for ( unsigned int col = 0; col < columns(); ++col )
		{
			int w = columnMode( col ) == Fixed ? 0 : scaleWidth / scaledColumns;
			if ( scaledColumns && col == lastScaledColumn ) w += scaleWidth - scaleWidth / scaledColumns * scaledColumns;

			if ( !tile( col, row ).isNull() )
				if ( w || h ) p->drawPixmap( xpos, ypos, scale( col, row, w, h ) );
				else p->drawPixmap( xpos, ypos, tile( col, row ) );
			xpos += w ? w : tile( col, row ).width();
		}
		ypos += h ? h : tile( 0, row ).height();
	}
}

QString TilePainter::absTileName( unsigned int column, unsigned int row ) const
{
	QString name = tileName( column, row );
	if ( name.isEmpty() ) return m_name;
	return m_name + "-" + name;
}

QString RectTilePainter::tileName( unsigned int column, unsigned int row ) const
{
	static QString c = "lcr", r = "tcb";
	return QString( r.mid( row, 1 ) + c.mid( column, 1 ) );
}

unsigned int TabPainter::columns() const
{
	Mode check = QApplication::reverseLayout() ? First : Last;
	return m_mode == check ? 3 : 2;
}

QString TabPainter::tileName( unsigned int column, unsigned int row ) const
{
	Mode check = QApplication::reverseLayout() ? Last : First;
	if ( column == 0 && m_mode != check ) return "separator";
		return RectTilePainter::tileName( column, row );
}

ScrollBarPainter::ScrollBarPainter( const QString& type, int count, bool horizontal )
	: TilePainter( name( horizontal ) ),
	  m_type( type ),
	  m_count( count ),
	  m_horizontal( horizontal )
{
}

QString ScrollBarPainter::name( bool horizontal )
{
	return QString( "scrollbar-" ) + ( horizontal ? "hbar" : "vbar" );
}

// vim: ts=4 sw=4 noet
